# 하이드레이션

## 하이드레이션이란 무엇인가요

하이드레이션은 서버 사이드 렌더링된 애플리케이션을 클라이언트에서 복원하는 과정입니다. 여기에는 서버에서 렌더링된 DOM 구조 재사용, 애플리케이션 상태 유지, 이미 서버에서 검색된 애플리케이션 데이터 전송 및 기타 과정이 포함됩니다.

## 하이드레이션이 중요한 이유는 무엇인가요?

하이드레이션은 DOM 노드를 재생성하기 위한 추가 작업을 피함으로써 애플리케이션 성능을 향상시킵니다. 대신, Angular는 런타임 중에 기존 DOM 요소와 애플리케이션 구조를 일치시키려고 하고 가능한 경우 DOM 노드를 재사용합니다. 이로 인해 [Core Web Vitals (CWV)](https://web.dev/learn-core-web-vitals/) 통계에서 측정할 수 있는 성능 향상이 발생합니다. 예를 들어, 첫 번째 입력 지연([FID](https://web.dev/fid/))과 가장 큰 콘텐츠 폴 페인트([LCP](https://web.dev/lcp/)), 누적 레이아웃 이동([CLS](https://web.dev/cls/))을 줄입니다. 이러한 수치를 개선하면 SEO 성능에도 영향을 미칩니다.

하이드레이션이 활성화되지 않은 경우, 서버 사이드 렌더링된 Angular 애플리케이션은 애플리케이션의 DOM을 파괴하고 다시 렌더링하여 눈에 띄는 UI 깜박임을 초래할 수 있습니다. 이 다시 렌더링은 [Core Web Vitals](https://web.dev/learn-core-web-vitals/)와 같은 [LCP](https://web.dev/lcp/)에 부정적인 영향을 미치고 레이아웃 이동을 일으킬 수 있습니다. 하이드레이션을 활성화하면 기존 DOM을 재사용할 수 있고 깜박임을 방지할 수 있습니다.

## Angular에서 하이드레이션을 활성화하는 방법

하이드레이션은 서버 사이드 렌더링(SSR) 애플리케이션에 대해서만 활성화할 수 있습니다. 먼저 [Angular SSR 가이드](guide/ssr)를 따라 서버 사이드 렌더링을 활성화하세요.

### Angular CLI 사용하기

Angular CLI를 사용하여 SSR을 활성화한 경우(애플리케이션 생성 중 또는 나중에 `ng add @angular/ssr`를 통해 활성화한 경우), 하이드레이션을 활성화하는 코드는 이미 애플리케이션에 포함되어 있어야 합니다.

### 수동 설정

사용자 지정 설정을 하고 Angular CLI를 사용하여 SSR을 활성화하지 않았다면, 주요 애플리케이션 컴포넌트나 모듈을 방문하고 `@angular/platform-browser`에서 `provideClientHydration`을 가져와 수동으로 하이드레이션을 활성화할 수 있습니다. 그런 다음 해당 프로바이더를 애플리케이션 부트스트랩 프로바이더 목록에 추가합니다.

```typescript
import {
  bootstrapApplication,
  provideClientHydration,
} from '@angular/platform-browser';
...

bootstrapApplication(AppComponent, {
  providers: [provideClientHydration()]
});
```

또는 NgModules를 사용하는 경우, `provideClientHydration`을 루트 앱 모듈의 프로바이더 목록에 추가합니다.

```typescript
import {provideClientHydration} from '@angular/platform-browser';
import {NgModule} from '@angular/core';

@NgModule({
  declarations: [AppComponent],
  exports: [AppComponent],
  bootstrap: [AppComponent],
  providers: [provideClientHydration()],
})
export class AppModule {}
```

중요: `provideClientHydration()` 호출이 애플리케이션을 **서버**에서 부트스트랩하는 데 사용되는 프로바이더 집합에 포함되어 있는지 확인하세요. 기본 프로젝트 구조( `ng new` 명령으로 생성된 구조)에서는 루트 `AppModule`에 대한 호출을 추가하는 것만으로 충분합니다. 사용자 지정 설정을 사용하는 경우, 서버 부트스트랩 구성에서 프로바이더 목록에 `provideClientHydration()` 호출을 추가하세요.

### 하이드레이션이 활성화되었는지 확인하기

하이드레이션을 구성하고 서버를 시작한 후, 브라우저에서 애플리케이션을 로드하세요.

도움말: 하이드레이션이 완전히 작동하기 전에 직접 DOM 조작 인스턴스를 수정해야 할 수도 있습니다. Angular 구조로 전환하거나 `ngSkipHydration`을 사용하여 문제를 해결하세요. 더 많은 세부정보는 [제약 사항](#constraints), [직접 DOM 조작](#direct-dom-manipulation), 및 [특정 컴포넌트에 대한 하이드레이션 건너뛰기 방법](#how-to-skip-hydration-for-particular-components)을 참조하세요.

개발 모드에서 애플리케이션을 실행하는 동안, 브라우저의 개발자 도구를 열고 콘솔을 확인하여 하이드레이션이 활성화되었는지 확인할 수 있습니다. 하이드레이션 관련 통계(하이드레이션된 컴포넌트 및 노드 수 포함)를 포함한 메시지를 볼 수 있어야 합니다. Angular는 페이지에 렌더링된 모든 컴포넌트, 제3자 라이브러리에서 가져온 컴포넌트를 포함하여 통계를 계산합니다.

또한 [Angular DevTools 브라우저 확장](tools/devtools)을 사용하여 페이지에서 컴포넌트의 하이드레이션 상태를 확인할 수 있습니다. Angular DevTools는 페이지에서 하이드레이션된 부분을 표시하는 오버레이를 활성화할 수도 있습니다. 하이드레이션 불일치 오류가 있는 경우, DevTools는 오류를 발생시킨 컴포넌트를 강조 표시합니다.

## 이벤트 캡처 및 재생

애플리케이션이 서버에서 렌더링되면 생성된 HTML이 로드되는 즉시 브라우저에서 보입니다. 사용자는 페이지와 상호작용할 수 있다고 가정할 수 있지만 하이드레이션이 완료될 때까지 이벤트 리스너가 연결되지 않습니다. v18부터, 하이드레이션이 완료된 후에 이러한 이벤트를 재생할 수 있도록 하이드레이션 완료 이전에 발생한 모든 이벤트를 캡처할 수 있는 이벤트 재생 기능을 활성화할 수 있습니다. 예를 들어 `withEventReplay()` 함수를 사용하여 이를 활성화할 수 있습니다:

```typescript
import {provideClientHydration, withEventReplay} from '@angular/platform-browser';

bootstrapApplication(App, {
  providers: [
    provideClientHydration(withEventReplay())
  ]
});
```

### 이벤트 재생
이벤트 재생은 하이드레이션이 완료되기 전에 발생한 사용자 이벤트를 캡처하고 이후에 재생하여 사용자 경험을 개선하는 기능입니다.

이벤트 재생은 세 가지 주요 단계로 나누어집니다:

- **사용자 상호작용 캡처**<br>
**하이드레이션** 이전에 이벤트 재생은 사용자가 수행할 수 있는 모든 상호작용(예: 클릭 및 기타 브라우저 기본 이벤트)을 캡처하고 저장합니다.

- **이벤트 저장**<br>
**이벤트 계약**은 이전 단계에서 기록된 모든 상호작용을 메모리에 유지하여 나중에 재생할 때 잃어버리지 않도록 합니다.

- **이벤트 재실행**<br>
**하이드레이션**이 완료되면 Angular는 캡처된 이벤트를 다시 호출하여 사용자의 작업 중 잃어버린 것이 없도록 합니다.

---

이 기능은 사용자가 하이드레이션 이전에 수행한 작업이 무시되는 것을 방지하여 일관된 사용자 경험을 보장합니다.

## 제약 사항

하이드레이션은 하이드레이션이 활성화되지 않은 경우에는 존재하지 않는 몇 가지 제약을 애플리케이션에 부여합니다. 애플리케이션은 서버와 클라이언트에서 동일한 생성된 DOM 구조를 가져야 합니다. 하이드레이션 프로세스는 두 위치에서 DOM 트리가 동일한 구조를 갖기를 기대합니다. 여기에는 Angular가 서버에서 렌더링하는 동안 생성하는 공백 및 주석 노드도 포함됩니다. 이러한 공백 및 노드는 서버 사이드 렌더링 프로세스에서 생성된 HTML에 존재해야 합니다.

중요: 서버 사이드 렌더링 작업에서 생성된 HTML은 서버와 클라이언트 간에 **변경되지 않아야** 합니다.

서버와 클라이언트의 DOM 트리 구조 간에 불일치가 있을 경우 하이드레이션 프로세스는 예상된 것과 실제 DOM에 존재하는 것과 일치시키는 과정에서 문제가 발생합니다. 네이티브 DOM API를 사용하여 직접 DOM 조작을 수행하는 컴포넌트가 가장 일반적인 원인입니다.

### 직접 DOM 조작

네이티브 DOM API를 사용하여 DOM을 조작하는 컴포넌트가 있거나 `innerHTML` 또는 `outerHTML`을 사용하는 경우, 하이드레이션 프로세스는 오류가 발생합니다. DOM 조작이 문제가 되는 특정 사례는 `document`에 접근하거나 특정 요소를 쿼리하거나 `appendChild`를 사용하여 추가 노드를 삽입하는 상황입니다. DOM 노드를 분리하고 다른 위치로 이동시키는 것도 오류를 발생시킵니다.

이는 Angular가 이러한 DOM 변경을 인식하지 못하고 하이드레이션 프로세스 중에 이를 해결할 수 없기 때문입니다. Angular는 특정 구조를 기대하지만 하이드레이션할 때 다른 구조를 만나게 됩니다. 이 불일치는 하이드레이션 실패로 이어지며 DOM 불일치 오류를 발생시킵니다 ([아래를 참조](#errors)).

이러한 종류의 DOM 조작을 피하도록 컴포넌트를 리팩토링하는 것이 가장 좋습니다. 가능하다면 Angular API를 사용하여 이 작업을 수행하십시오. 이러한 동작을 리팩토링할 수 없다면, 하이드레이션 친화적인 솔루션으로 리팩토링할 수 있을 때까지 `ngSkipHydration` 속성을 사용하세요 ([아래에 설명](#how-to-skip-hydration-for-particular-components)).

### 유효한 HTML 구조

유효한 HTML 구조가 없는 컴포넌트 템플릿이 있는 경우, 하이드레이션 중 DOM 불일치 오류가 발생할 수 있는 몇 가지 경우가 있습니다.

예를 들어, 이 문제의 가장 일반적인 몇 가지 경우입니다.

- `<table>` 내부에 `<tbody>`가 없음
- `<p>` 내부에 `<div>`가 있음
- 다른 `<a>` 내부에 `<a>`가 있음

HTML이 유효한지 확신이 없는 경우 [구문 검사기](https://validator.w3.org/)를 사용하여 확인할 수 있습니다.

주의: HTML 표준은 테이블 안에 `<tbody>` 요소를 요구하지 않지만, 현대 브라우저는 `<tbody>`를 선언하지 않은 테이블에서 자동으로 `<tbody>` 요소를 생성합니다. 이러한 불일치로 인해 하이드레이션 오류를 방지하기 위해 항상 테이블에 `<tbody>` 요소를 명시적으로 선언하세요.

### 공백 유지 구성

하이드레이션 기능을 사용할 때, `preserveWhitespaces`에 대해 기본값 `false`를 사용하는 것을 권장합니다. 이 설정이 tsconfig에 없으면 값은 `false`가 되며 변경이 필요 없습니다. `preserveWhitespaces: true`를 tsconfig에 추가하여 공백을 유지하도록 설정하기로 선택하면, 하이드레이션에 문제가 발생할 수 있습니다. 이는 아직 완전히 지원되는 구성은 아닙니다.

도움말: 이 설정이 서버에 대한 `tsconfig.server.json`과 브라우저 빌드에 대한 `tsconfig.app.json`에서 **일관되게** 설정되어 있는지 확인하세요. 값이 불일치하면 하이드레이션이 중단됩니다.

이 설정을 tsconfig에 설정하기로 선택하면, 기본적으로 `tsconfig.server.json`이 이를 상속하므로 `tsconfig.app.json`에서만 설정하는 것이 좋습니다.

### 사용자 지정 또는 Noop Zone.js는 아직 지원되지 않음

하이드레이션은 Angular가 서버에서 직렬화 프로세스를 시작하거나 클라이언트에서 하이드레이션 이후 정리 작업을 시작할 수 있도록 할 수 있는 신호를 Zone.js로부터 필요로 합니다. 이는 미처 청구되지 않은 DOM 노드를 제거하기 위한 것입니다.

사용자 정의 Zone.js 구현이나 "noop" Zone.js 구현을 제공하면 "안정적인" 이벤트의 타이밍이 달라져 직렬화 또는 정리가 너무 일찍 또는 너무 늦게 발생할 수 있습니다. 이는 아직 완전히 지원되는 구성이 아니며, 사용자 지정 Zone.js 구현에서 `onStable` 이벤트의 타이밍을 조정해야 할 수도 있습니다.

## 오류

노드 불일치에서부터 유효하지 않은 호스트 노드에서 `ngSkipHydration`을 사용한 경우까지 여러 가지 하이드레이션 관련 오류가 발생할 수 있습니다. 가장 일반적인 오류 사례는 네이티브 API를 사용하여 직접 DOM 조작을 수행하여 클라이언트에서 서버에 의해 렌더링된 예상 DOM 트리 구조를 찾거나 일치시키는 데 실패하여 발생하는 것입니다. 이러한 유형의 오류를 경험할 수 있는 다른 경우는 위에서 언급한 [유효한 HTML 구조](#valid-html-structure) 섹션에서 설명했습니다. 템플릿에 있는 HTML이 유효한 구조를 사용하고 있는지 확인하면 이러한 오류 사례를 피할 수 있습니다.

하이드레이션 관련 오류에 대한 전체 참조는 [오류 참조 가이드](/errors)를 방문하세요.

## 특정 컴포넌트에 대한 하이드레이션 건너뛰기 방법

일부 컴포넌트는 이전에 언급한 문제(예: [직접 DOM 조작](#direct-dom-manipulation) 등)로 인해 하이드레이션이 활성화된 경우 제대로 작동하지 않을 수 있습니다. 해결 방법으로, 컴포넌트 태그에 `ngSkipHydration` 속성을 추가하여 전체 컴포넌트의 하이드레이션을 건너뛸 수 있습니다.

```angular-html
<app-example ngSkipHydration />
```

대안으로 `ngSkipHydration`을 호스트 바인딩으로 설정할 수 있습니다.

```typescript
@Component({
  ...
  host: {ngSkipHydration: 'true'},
})
class ExampleComponent {}
```

`ngSkipHydration` 속성은 Angular가 전체 컴포넌트 및 그 자식을 하이드레이션하는 것을 건너뛰도록 강제합니다. 이 속성을 사용하면 컴포넌트가 하이드레이션이 활성화되지 않은 것처럼 동작하므로 스스로를 파괴하고 다시 렌더링합니다.

도움말: 이렇게 하면 렌더링 문제가 해결되지만, 이 컴포넌트(및 그 자식들)에 대해 하이드레이션의 이점을 얻지 못하게 됩니다. 하이드레이션을 방해하는 패턴(예: 직접 DOM 조작)을 피하기 위해 컴포넌트의 구현을 조정해야 하며, 그렇게 할 수 있을 때까지 하이드레이션 건너뛰기 주석을 제거할 수 있습니다.

`ngSkipHydration` 속성은 컴포넌트 호스트 노드에서만 사용할 수 있습니다. 이 속성을 다른 노드에 추가하면 Angular는 오류를 발생시킵니다.

루트 애플리케이션 컴포넌트에 `ngSkipHydration` 속성을 추가하면 애플리케이션 전체에 대한 하이드레이션이 실질적으로 비활성화됩니다. 이 속성을 사용할 때는 주의하고 신중하게 고려하세요. 이는 최후의 수단으로 사용될 수 있는 일회성 해결책입니다. 하이드레이션을 방해하는 컴포넌트는 수정해야 할 버그로 간주해야 합니다.

## 하이드레이션 타이밍 및 애플리케이션 안정성

애플리케이션 안정성은 하이드레이션 프로세스의 중요한 부분입니다. 하이드레이션 및 모든 하이드레이션 후 프로세스는 애플리케이션이 안정성을 보고한 후에만 발생합니다. 안정성이 지연될 수 있는 여러 가지 방법이 있습니다. 여기에는 타임아웃 및 간격 설정, 해결되지 않은 약속 및 보류 중인 마이크로 작업 등이 포함됩니다. 이러한 경우에는 [애플리케이션이 불안정하게 유지됩니다](errors/NG0506) 오류가 발생할 수 있으며, 이는 앱이 10초 후 아직 안정 상태에 도달하지 않았음을 나타냅니다. 애플리케이션이 즉시 하이드레이션되지 않는 경우, 애플리케이션 안정성에 영향을 미치는 요소를 살펴보고 이러한 지연을 유발하지 않도록 리팩토링하세요.

## I18N

도움말: 하이드레이션과 함께 국제화를 위한 지원이 현재 [개발자 미리보기](/reference/releases#developer-preview) 상태입니다. 기본적으로 Angular는 i18n 블록을 사용하는 컴포넌트의 하이드레이션을 건너뛰어 사실상 해당 컴포넌트를 처음부터 다시 렌더링합니다.

i18n 블록에 대한 하이드레이션을 활성화하려면, `provideClientHydration` 호출에 [`withI18nSupport`](/api/platform-browser/withI18nSupport)를 추가할 수 있습니다.

```typescript
import {
  bootstrapApplication,
  provideClientHydration,
  withI18nSupport,
} from '@angular/platform-browser';
...

bootstrapApplication(AppComponent, {
  providers: [provideClientHydration(withI18nSupport())]
});
```

## 서버 측과 클라이언트 측에서 일관된 렌더링
서버 사이드 렌더링과 클라이언트 사이드 렌더링이 다른 콘텐츠를 표시하는 `@if` 블록 및 기타 조건문을 도입하지 마세요. 예를 들어 Angular의 `isPlatformBrowser` 함수로 `@if` 블록을 사용하는 경우와 같은 상황입니다. 이러한 렌더링 차이는 레이아웃 이동을 발생시켜 최종 사용자 경험 및 핵심 웹 지표에 부정적인 영향을 미칩니다.

## DOM 조작이 있는 타사 라이브러리

DOM 조작에 의존하여 렌더링할 수 있는 여러 타사 라이브러리가 있습니다. D3 차트가 대표적인 예입니다. 이러한 라이브러리는 하이드레이션 없이 작동했으나 하이드레이션이 활성화되면 DOM 불일치 오류를 일으킬 수 있습니다. 지금은 이러한 라이브러리를 사용할 때 DOM 불일치 오류가 발생하면 해당 라이브러리를 사용하는 컴포넌트에 `ngSkipHydration` 속성을 추가할 수 있습니다.

## DOM 조작이 있는 타사 스크립트

많은 타사 스크립트(예: 광고 추적기 및 분석)는 하이드레이션이 발생하기 전에 DOM을 수정합니다. 이러한 스크립트는 페이지가 더 이상 Angular에서 예상하는 구조와 일치하지 않기 때문에 하이드레이션 오류를 발생시킬 수 있습니다. 가능하다면 하이드레이션 이후 이 유형의 스크립트를 미루는 것이 좋습니다. 후속 프로세스가 발생한 후까지 스크립트를 지연시키기 위해 [`AfterNextRender`](api/core/afterNextRender)를 사용하는 것을 고려하세요.

## 점진적 하이드레이션

점진적 하이드레이션은 하이드레이션이 발생하는 시점에 대한 더 세분화된 제어를 허용하는 고급 형태의 하이드레이션입니다. 자세한 정보는 [점진적 하이드레이션 가이드](guide/incremental-hydration)를 참조하세요.