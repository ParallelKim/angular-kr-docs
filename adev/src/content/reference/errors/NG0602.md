# 반응형 컨텍스트 내에서 허용되지 않은 함수 호출

반응형 컨텍스트 내에서 실행이 허용되지 않은 함수가 반응형 컨텍스트 내에서 호출되었습니다.

예를 들어, `computed` 또는 활성 실행 효과 내에서 `effect`를 예약할 수 없습니다. 템플릿 표현식의 일부분으로 `effect`와 같은 함수를 호출하는 것을 피하십시오. 이러한 함수는 자신의 반응형 컨텍스트 내에서 실행됩니다.

계산된 표현식은 순수한 것으로 기대됩니다. 순수하다는 것은 표현식이 부작용을 발생시키지 않음을 의미합니다. 부작용은 `afterRender` 예약, 새로운 `effect` 생성 또는 관측 가능 항목에 구독하는 것과 같은 작업입니다.

일부 작업은 일반적인 함정에 빠지지 않도록 반응형 컨텍스트 내에서 명시적으로 금지됩니다. 예를 들어, `computed` 내에서 `afterRender`를 사용하면 계산된 표현식이 평가될 때마다 새로운 렌더 후크가 예약됩니다. 이는 의도되지 않았을 가능성이 크며 애플리케이션 성능을 저하시킬 수 있습니다.

### 오류 수정

이 오류 가이드는 포괄적이지 않습니다. 몇 가지 일반적인 시나리오와 오류를 해결하는 방법을 포함합니다.

#### `afterRender`
`afterRender` 호출을 반응형 컨텍스트 밖으로 이동하십시오.

렌더 후크를 예약하는 좋은 장소는 컴포넌트의 클래스 생성자입니다. 또는 `untracked`를 사용하여 반응형 컨텍스트를 떠나고 이 오류에서 명시적으로 벗어날 수 있습니다.

#### `effect`
`effect` 호출을 반응형 컨텍스트 밖으로 이동하십시오.

효과를 예약하는 좋은 장소는 `@Component`의 클래스 생성자입니다.

#### `toSignal`
`toSignal` 호출을 반응형 컨텍스트 밖으로 이동하십시오.

```typescript
result = computed(() => {
  const dataSignal = toSignal(dataObservable$);
  return doSomething(dataSignal());
});
```

다음과 같이 리팩토링할 수 있습니다:

```typescript
dataSignal = toSignal(dataObservable$);
result = computed(() => doSomething(dataSignal()));
```

또는, 이것이 불가능하다면 관측 가능 항목에 수동으로 구독하는 것을 고려하십시오.

마지막 수단으로 `untracked`를 사용하여 반응형 컨텍스트를 떠나십시오. 반응형 컨텍스트를 떠나면 `untracked` 내부에서 신호 읽기가 무시될 수 있으므로 주의하십시오.

@디버깅

오류 메시지는 예상치 못하게 호출된 함수를 언급합니다. 애플리케이션 코드에서 이 함수 호출을 찾으십시오.

또는 브라우저의 스택 추적에서 함수가 호출된 위치와 위치를 확인할 수 있습니다.